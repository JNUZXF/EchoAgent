好的，这是一个非常专业且实践性的问题。为 AI Agent 打包和管理 `tools` 的 schema 信息，如果采用简单地手写字典或 JSON 的方式，会变得非常繁琐、易错且难以维护。

“高阶”的 Python 代码方法，其核心思想是 **“代码即定义” (Code as Definition)**。我们应该利用 Python 语言的特性（如函数签名、类型注解、文档字符串），让 Schema 信息能够从代码中 **自动生成**，而不是手动维护一份副本。

这里，我将为你介绍目前业界最优雅、最主流的方案：**结合使用 Pydantic 和装饰器 (Decorators)**。

-----

### 核心痛点：为什么需要高阶方法？

先看一个“低阶”的例子：

```python
# 手动维护 Schema，非常痛苦
def get_current_weather(city: str, unit: str = "celsius"):
    """获取指定城市的当前天气"""
    # ... 函数实现 ...
    pass

tools_schema = [
    {
        "type": "function",
        "function": {
            "name": "get_current_weather",
            "description": "获取指定城市的当前天气",
            "parameters": {
                "type": "object",
                "properties": {
                    "city": {
                        "type": "string",
                        "description": "城市名称, e.g., Beijing"
                    },
                    "unit": {
                        "type": "string",
                        "enum": ["celsius", "fahrenheit"],
                        "description": "温度单位"
                    }
                },
                "required": ["city"]
            }
        }
    }
]
```

这种方法的**缺点**显而易见：

1.  **重复劳动**：函数签名和 Schema 定义了同样的信息。
2.  **同步噩梦**：如果你修改了 `get_current_weather` 函数的参数（比如增加一个 `date` 参数），你必须手动去修改 `tools_schema` 字典，否则两者就会不一致，导致 Agent 调用失败。
3.  **容易出错**：手写 JSON/字典很容易出现拼写错误、格式错误。
4.  **代码可读性差**：业务逻辑（函数）和元数据（Schema）分离，维护心智负担重。

-----

### 高阶方案：使用 Pydantic 和装饰器

我们的目标是：**只编写 Python 函数，Schema 自动生成**。

**Pydantic** 是一个基于 Python 类型注解的数据验证和设置管理库。它最强大的功能之一就是可以根据一个数据类（Model）自动生成对应的 **JSON Schema**。这正是我们需要的！

#### 第 1 步：安装 Pydantic

```bash
pip install pydantic
```

#### 第 2 步：为函数的“参数”定义 Pydantic 模型

我们不直接为函数写 Schema，而是为函数的 **参数集合** 创建一个 Pydantic 模型。

```python
from pydantic import BaseModel, Field
from typing import Literal, Optional

# 1. 为 get_weather 函数的参数创建一个 Pydantic 模型
class WeatherArgs(BaseModel):
    """
    定义了 get_weather 函数所需要的所有参数。
    Pydantic 会利用这些字段、类型注解和 Field 描述来生成 JSON Schema。
    """
    city: str = Field(..., description="城市名称, 例如: '北京', 'San Francisco'")
    unit: Literal["celsius", "fahrenheit"] = Field(
        default="celsius",
        description="要使用的温度单位"
    )

# 2. 编写你的业务逻辑函数
def get_weather(args: WeatherArgs):
    """获取一个给定城市的当前天气情况"""
    print(f"正在为城市 {args.city} 获取天气，单位：{args.unit}...")
    # 在这里实现真实的 API 调用逻辑
    if args.city == "北京":
        return f"北京目前天气晴朗，温度为 25°{args.unit}."
    elif args.city == "东京":
        return f"东京正在下雨，温度为 20°{args.unit}."
    else:
        return f"{args.city} 的天气信息不存在。"

```

**说明**:

  - `BaseModel`: Pydantic 的基类，所有数据模型都应继承它。
  - `Field`: 用于为字段添加额外的元数据，比如 `description`（这对 LLM 理解参数至关重要）、`default` 值、校验规则等。
  - `Literal`: 使用 `typing.Literal` 可以完美地映射到 JSON Schema 的 `enum` 类型。
  - 函数的参数现在变成了一个 `WeatherArgs` 对象，这让代码更清晰，并且 Pydantic 会在调用前自动验证传入的数据。

#### 第 3 步：创建一个通用的“工具”装饰器

这是最关键的一步，我们将创建一个 `@tool` 装饰器，它会自动完成 Schema 的打包工作。

```python
import inspect
import json
from functools import wraps

def tool(func):
    """
    一个装饰器，用于将一个函数标记为 AI Agent 的工具，
    并自动从函数的签名和 Pydantic 模型中提取 Schema。
    """
    # 1. 从函数签名中获取参数模型
    sig = inspect.signature(func)
    params = sig.parameters
    
    # 我们约定，函数的第一个参数必须是 Pydantic 模型，并且有类型注解
    if not params:
        raise ValueError("Tool function must have at least one Pydantic model argument.")
    
    first_param_name = next(iter(params))
    args_model = params[first_param_name].annotation

    if not issubclass(args_model, BaseModel):
        raise TypeError("The first argument of a tool function must be a Pydantic BaseModel.")

    # 2. 从 Pydantic 模型生成 JSON Schema
    parameters_schema = args_model.model_json_schema()

    # 3. 组装成 Agent 需要的完整 Tool Schema
    tool_schema = {
        "type": "function",
        "function": {
            "name": func.__name__,
            "description": func.__doc__,
            "parameters": parameters_schema
        }
    }
    
    # 4. 将 Schema 和原始函数附加到包装函数上，方便后续调用
    @wraps(func)
    def wrapper(*args, **kwargs):
        # 实际调用时，仍然执行原始函数
        return func(*args, **kwargs)
    
    # 将 schema 和原始可调用函数附加到 wrapper 对象上
    wrapper.schema = tool_schema
    wrapper.executable = func 
    
    return wrapper

```

#### 第 4 步：应用装饰器并构建工具箱

现在，我们可以像变魔术一样简单地定义和注册我们的工具了。

```python
# --- 使用我们强大的 @tool 装饰器 ---

@tool
def get_weather(args: WeatherArgs):
    """获取一个给定城市的当前天气情况"""
    print(f"正在为城市 {args.city} 获取天气，单位：{args.unit}...")
    if args.city == "北京":
        return f"北京目前天气晴朗，温度为 25°{args.unit}."
    elif args.city == "东京":
        return f"东京正在下雨，温度为 20°{args.unit}."
    else:
        return f"{args.city} 的天气信息不存在。"


# --- 再定义一个工具 ---
class StockPriceArgs(BaseModel):
    symbol: str = Field(..., description="股票代码, 例如: 'GOOGL', 'AAPL'")

@tool
def get_stock_price(args: StockPriceArgs):
    """查询指定股票代码的当前价格"""
    print(f"正在查询股票 {args.symbol} 的价格...")
    if args.symbol == "GOOGL":
        return "GOOGL 当前价格为 $1500."
    else:
        return f"未找到股票 {args.symbol} 的价格信息。"


# --- 构建一个工具注册表/管理器 ---

class ToolRegistry:
    def __init__(self):
        self.tools = {} # 存储 name -> callable function
        self.schemas = [] # 存储所有工具的 Schema 列表

    def register(self, tool_func):
        """注册一个被 @tool 装饰过的函数"""
        if not hasattr(tool_func, 'schema'):
            raise ValueError("Function must be decorated with @tool to be registered.")
            
        name = tool_func.schema['function']['name']
        self.tools[name] = tool_func.executable
        self.schemas.append(tool_func.schema)
        print(f"工具 '{name}' 已注册。")

    def get_schemas(self):
        """获取所有工具的 Schema 列表，可以直接发给 LLM"""
        return self.schemas

    def execute(self, tool_name: str, arguments_json: str):
        """根据 LLM 返回的名称和参数，执行对应的工具"""
        if tool_name not in self.tools:
            return f"错误: 工具 '{tool_name}' 不存在。"
        
        try:
            # 使用 Pydantic 模型自动解析和验证 JSON 参数
            func = self.tools[tool_name]
            sig = inspect.signature(func)
            param_model = next(iter(sig.parameters.values())).annotation
            
            # 这一步是关键：Pydantic 会验证LLM返回的JSON，如果格式不对会直接报错
            args_obj = param_model.model_validate_json(arguments_json)
            
            return func(args_obj)
        except Exception as e:
            return f"执行工具 '{tool_name}' 时出错: {e}"

# --- 使用示例 ---

# 1. 创建并注册工具
registry = ToolRegistry()
registry.register(get_weather)
registry.register(get_stock_price)

# 2. 获取打包好的 Schema 列表 (这部分将发送给 AI Agent)
all_tool_schemas = registry.get_schemas()

print("\n--- 打包好的所有 Tool Schemas ---")
print(json.dumps(all_tool_schemas, indent=2, ensure_ascii=False))

# 3. 模拟 AI Agent 的返回，并执行
print("\n--- 模拟执行 Agent 的调用 ---")
# 假设 Agent (LLM) 返回了需要调用 'get_weather'
agent_tool_name = "get_weather"
agent_arguments_json = '{"city": "东京", "unit": "celsius"}'

result = registry.execute(agent_tool_name, agent_arguments_json)
print(f"执行结果: {result}")

# 模拟 Agent 调用另一个工具
agent_tool_name_2 = "get_stock_price"
agent_arguments_json_2 = '{"symbol": "GOOGL"}'
result_2 = registry.execute(agent_tool_name_2, agent_arguments_json_2)
print(f"执行结果: {result_2}")
```

### 总结：这种高阶方法的优势

1.  **单一事实来源 (Single Source of Truth)**：**Python 函数本身**（包括其名称、文档字符串、参数的 Pydantic 模型）就是 Schema 的唯一来源。修改函数或 Pydantic 模型，Schema 就会自动更新。
2.  **自动化和零同步成本**：彻底告别手动维护 JSON/字典，杜绝了函数与 Schema 不一致的问题。
3.  **强类型与数据验证**：当 LLM 返回参数后，`ToolRegistry` 在执行前使用 Pydantic 模型 (`model_validate_json`) 对参数进行解析和验证。如果 LLM 生成了不合规的参数（例如，`unit` 给了个 `kelvin`），程序会立刻抛出验证错误，而不是等到业务逻辑深处才报错，极大增强了代码的健壮性。
4.  **极佳的可读性和可维护性**：代码非常清晰。一个开发者看到 `@tool` 装饰器和 Pydantic 模型，就能立刻理解这个函数是干什么、需要什么参数，以及它的描述是什么。
5.  **易于扩展**：添加一个新工具，只需要定义一个新的 Pydantic 模型和一个被 `@tool` 装饰的函数，然后注册它即可，完全符合“开闭原则”。

这种**代码驱动 Schema** 的方式是构建复杂、可靠、可维护的 AI Agent 系统时的最佳实践。它将繁琐的元数据管理工作自动化，让开发者可以更专注于实现工具本身的核心业务逻辑。